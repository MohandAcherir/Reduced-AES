#include <stdio.h>
#include <string.h>



void Dernier_Tour(unsigned char Matrice_Etat[4][4], unsigned char Cle_Tour[][4]);
void Tour(unsigned char Matrice_Etat[4][4], unsigned char Cle_Tour[][4]);
void ExtensionCle1(unsigned char cle_maitre[16], unsigned char cle_etendue[20][4]);
void AjoutCleTour(unsigned char Matrice_Etat[4][4], unsigned char Cle_Tour[][4]);
void RotationOctet(unsigned char arr[4]);
void AjoutCleTour(unsigned char Matrice_Etat[4][4], unsigned char Cle_Tour[][4]);
void MelangeColonnes(unsigned char Matrice_Etat[4][4]);
void DecaleLignes(unsigned char Matrice_Etat[4][4]);
void SubWord(unsigned char arr[4]);
unsigned char SubByte(unsigned char byte);
void SubOctet(unsigned char Matrice_Etat[4][4]);
unsigned char SubOctetInverse(unsigned char byte);
void ExtensionCleBis(unsigned char cle_maitre[16], unsigned char cle_etendue[20][4]);


// Retrouver où mènent les coordonnées de (x, y) après le décalage 
int DecaleLignesXY(int x, int y) {	

	if(x == 0) {
		return y;
	}

	else if(x == 1) {
		return ((y-1)%4 >= 0 ) ? (y-1)%4 : (y-1)%4 + 4;
	}
	else if(x == 2) {
		return ((y-2)%4 >= 0 ) ? (y-2)%4 : (y-2)%4 + 4;
	}
	else {
		return ((y-3)%4 >= 0 ) ? (y-3)%4 : (y-3)%4 + 4;
	}

	return y;
}

// Retrouver où mènent les coordonnées de (x, y) après la Permutation Additionnelle
// et les stocker dans (nx, ny)
void permXY(int x, int y, int* nx, int* ny) {

	if(x == 0 && y == 0) {
		*nx = x;
		*ny = y;
	}
	else if(x == 1 && y == 0) {
		*nx = 0;
		*ny = 1;
	}
	else if(x == 2 && y == 0) {
		*nx = 0;
		*ny = 2;
	}
	else if(x == 3 && y == 0) {
		*nx = 0;
		*ny = 3;
	}
	else if(x == 1 && y == 3) {
		*nx = 1;
		*ny = 0;
	}
	else if(x == 2 && y == 3) {
		*nx = 1;
		*ny = 1;
	}
	else if(x == 3 && y == 3) {
		*nx = 1;
		*ny = 2;
	}
	else if(x == 0 && y == 3) {
		*nx = 1;
		*ny = 3;
	}
	else if(x == 2 && y == 2) {
		*nx = 2;
		*ny = 0;
	}
	else if(x == 3 && y == 2) {
		*nx = 2;
		*ny = 1;
	}
	else if(x == 0 && y == 2) {
		*nx = 2;
		*ny = 2;
	}
	else if(x == 1 && y == 2) {
		*nx = 2;
		*ny = 3;
	}
	else if(x == 3 && y == 1) {
		*nx = 3;
		*ny = 0;
	}
	else if(x == 0 && y == 1) {
		*nx = 3;
		*ny = 1;
	}
	else if(x == 1 && y == 1) {
		*nx = 3;
		*ny = 2;
	}
	else if(x == 2 && y == 1) {
		*nx = 3;
		*ny = 3;
	}
}


// Retrouver la sous-clé K4
void CalculateK4(unsigned char D[256][4][4], unsigned char K4[4][4], unsigned char C[256][4][4]) {
	unsigned char a = 0x00;

	for(int x = 0 ; x < 4 ; x++) {
		for(int y = 0 ; y < 4 ; y++) {
			// Pour chaque case de K4

			a = 0x00;
			for(int b = 0 ; b < 256 ; b++) {
				// Pour chaque caractère entre 0 et 255

				unsigned char XORING = 0x00;

				int y1 = DecaleLignesXY(x, y);
				int x1;

				int y2 = y1;

				permXY(x, y2, &x1, &y1);

				// DecaleLigneXY + PermXY pour retrouver les coordonnées correspondantes de C[i](x, y) dans K4
				unsigned char byte, X;
				for(int i = 0 ; i < 256 ; i++) { // Trouver C[i] (x, y) et XOR-er
					// Pour chacune des 256 matrices C
					byte = D[i][x1][y1] ^ a;

					X = SubOctetInverse (byte);

					XORING = XORING ^ X; 
				}

				unsigned char XORING2; 

				if(XORING == 0x00) { // Si finalement le XORING précédent est à 0
					for(int i = 0 ; i < 256 ; i++) { // Vérifier que C et D sont cohérentes avec cette valeur de a
						XORING2 = SubByte(C[i][x][y]) ^ a;

						if(D[i][x1][y1] == XORING2) { // Valeur trouvée
							K4[x1][y1] = a;
							break;
						}
					}
				}
				a = a + 0x01; // passer au caractère suivant
			}
		}
	}
}



// Initialiser les matrice B(i) selon l'attaque à clairs choisis
// La valeur c = 0x22
void init_D(unsigned char B[256][4][4]) {
	unsigned char c = 0x22;
	unsigned char counter = 0x00;

	for(int i = 0 ; i < 256 ; i++) {
		for(int x = 0 ; x < 4 ; x++) {
			for(int y = 0 ; y < 4 ; y++) {
				if(x == 0 && y == 0) {
					B[i][x][y] = counter;
				}
				else {
					B[i][x][y] = c;
				}
			}
		}
		counter = counter + 0x01;
	}
}
// Implémentation de l'AES réduit à 4 tours

int AES_128_4(unsigned char Matrice_Etat[4][4], unsigned char Cle_Maitre[16], unsigned char C[4][4]) {
	unsigned char Cle_Etendu[20][4];

	ExtensionCle1(Cle_Maitre, Cle_Etendu);

	AjoutCleTour(Matrice_Etat, Cle_Etendu);

	for(int i = 1 ; i < 4 ; i++) { // 3 tours
		Tour(Matrice_Etat, Cle_Etendu + 4*i);
	}

	for(int i = 0 ; i < 4 ; i++) { // Stocker par la même occasion les matrices C(i)
		for(int j = 0 ; j < 4 ; j++) {
			C[i][j] = Matrice_Etat[i][j];	
		}
	}

	Dernier_Tour(Matrice_Etat, Cle_Etendu + 4*4); // Dernier tour sans mélange Colonnes
}


int main() {
	unsigned char D[256][4][4]; // Matrices chiffrées avec l'AES réduit à 4 tours
	unsigned char C[256][4][4]; // Matrices chiffrées avec l'AES réduit à 3 tours complets

	unsigned char MyK[16]; // La clé maitre que l'on va donner au programme 

	printf("\nEntrez cle maitre: \n");
	for(int i = 0 ; i < 16 ; i++) {
		scanf("%2hhx", &(MyK[i]));
	}


	unsigned char MyHackedK41[4][4]; // Le réceptacle de K4 qu'on aura devinée(dimensions 1x16)
	unsigned char MyHackedK42[16];   // Le réceptacle de K4 qu'on aura devinée(dimensions 4x4)
	unsigned char ExtendedK[20][4];  // Clé étendue de 20 lignes

	init_D(D); // Initialiser avec les clairs choisis

	for(int i = 0 ; i < 256 ; i++) {
		AES_128_4(D[i], MyK, C[i]); // Chiffrer avec l'AES réduit
	}

    /* ************ Partie Attaque *********** */

	CalculateK4(D, MyHackedK41, C); // Attaquer pour deviner K4 et la stocker dans MyHackedK41

	for(int i = 0 ; i < 4 ; i++) { // Changement de dimension de 1x16 à 4x4 pour K4
		for(int j = 0 ; j < 4 ; j++) {
			MyHackedK42[(4*i)+j] = MyHackedK41[i][j];
		}
	}

	ExtensionCleBis(MyHackedK42, ExtendedK); // Déduire K, la clé maitre principale

	// Affichages
	
	printf("\nReal used K:\n");
	for(int i = 0 ; i < 4 ; i++) {
		for(int j = 0 ; j < 4 ; j++) {
			printf("%x, ", MyK[(4*i)+j]);
		}
		printf("\n");
	}

	printf("\nReal generated K4:\n");
	for(int i = 16 ; i < 20 ; i++) {
		for(int j = 0 ; j < 4 ; j++) {
			printf("%x, ", ExtendedK[i][j]);
		}
		printf("\n");
	}

	printf("\n\n------------------\n\nMy Hacked K4:\n");
	for(int i = 0 ; i < 4 ; i++) {
		for(int j = 0 ; j < 4 ; j++) {
			printf("%x, ", MyHackedK42[(4*i)+j]);
		}
		printf("\n");
	}

	printf("\nMy Hacked K:\n");
	for(int i = 0 ; i < 4 ; i++) {
		for(int j = 0 ; j < 4 ; j++) {
			printf("%x, ", ExtendedK[i][j]);
		}
		printf("\n");
	}

	int identical = 1;
	for(int i = 0 ; i < 4 ; i++) {
		for(int j = 0 ; j < 4 ; j++) {
			if(ExtendedK[i][j] != MyK[(4*i)+j]) {
				identical = 0;
			}
		}
	}

	if(identical == 1) {
		printf("\nCongrats, Keys match, Acces Granted !!!\n\n");
	}
	else {
		printf("\nAcces Denied, come back when you're no longer a rocky\n");
	}


	return 0;
}